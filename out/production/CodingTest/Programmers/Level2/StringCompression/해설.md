가장 쉬운 문제래 ㅠ

문자열의 길이가 최대 1,000으로 제한이 크지 않기 때문에 __가능한 모든 방법__ 을 탐색하면 된다.

문자열의 길이가 N일때 길이가 N/2 보다 크게 잘랐을 때는 길이가 줄지 않는다. (당연한 말이니 다시 생각해보기)
그래서 1 ~ N/2 길이로 자르는 방법을 모두 탐색한 후 그 중 가장 짧은 방법을 선택하면 된다.

생각한 접근 방법은 한 60% 정도 맞았다. 큰 길이 부터 1의 길이까지 자르는 범위를 줄여나가는 것. 
다만 length 길이 만큼 부터 줄여나가는 것이 아니라 length/2 부터 줄여나가는 것이었음.

역시나 prev, now가 아니라 now, next를 비교해야 했었고..
생각한 것은 얼추 맞았지만 구현 실력이 떨어져서 못한게 너무 아쉽읍니다

참조 = https://loosie.tistory.com/440

1. r의 길이만큼 패턴을 구해준다. s.substring(0,r);
   1. r의 길이는 [1, s의길이/2]의 범위를 가진다.
2. 패턴의 다음 문자열부터 순차적으로 탐색하여 연속되는 데이터를 찾는다.
   1. 탐색의 범위는 i : [r, s의 길이-r] 로, 매 증가는 i+=r
   2. 연속되는 문자열을 카운트해준다. if(pattern.equals(s.substring(i,i+r)))
   3. 연속이 끊기는 부분에서 해당 탐색한 문자열들의 정보(reStr)을 저장해준다.
3. 이렇게 모든 문자열들의 압축정보를 구해서 최솟값을 출력해준다.